<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Agex-svn] r10 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/agex-svn/2005-May/index.html" >
   <LINK REL="made" HREF="mailto:agex-svn%40lists.berlios.de?Subject=Re%3A%20%5BAgex-svn%5D%20r10%20-%20trunk&In-Reply-To=%3C200505261149.j4QBnQ1G013062%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000004.html">
   <LINK REL="Next"  HREF="000006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Agex-svn] r10 - trunk</H1>
    <B>Ilmar Kruis at BerliOS</B> 
    <A HREF="mailto:agex-svn%40lists.berlios.de?Subject=Re%3A%20%5BAgex-svn%5D%20r10%20-%20trunk&In-Reply-To=%3C200505261149.j4QBnQ1G013062%40sheep.berlios.de%3E"
       TITLE="[Agex-svn] r10 - trunk">seaeagle1 at sheep.berlios.de
       </A><BR>
    <I>Thu May 26 13:49:26 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000004.html">[Agex-svn] r9 - in trunk/AGES: . AGESDemo DirectSound OpenAL
</A></li>
        <LI>Next message: <A HREF="000006.html">[Agex-svn] r11 - in trunk: . mp3.NET
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5">[ date ]</a>
              <a href="thread.html#5">[ thread ]</a>
              <a href="subject.html#5">[ subject ]</a>
              <a href="author.html#5">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: seaeagle1
Date: 2005-05-26 13:49:25 +0200 (Thu, 26 May 2005)
New Revision: 10

Added:
   trunk/App.ico
   trunk/AssemblyInfo.cs
   trunk/Frame.cs
   trunk/Header.cs
   trunk/MP3Stream.cs
   trunk/dnpb.exe
   trunk/prebuild.xml
Log:
mp3.NET mp3 decoder import

Added: trunk/App.ico
===================================================================
(Binary files differ)


Property changes on: trunk/App.ico
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/AssemblyInfo.cs
===================================================================
--- trunk/AssemblyInfo.cs	2005-05-25 15:33:39 UTC (rev 9)
+++ trunk/AssemblyInfo.cs	2005-05-26 11:49:25 UTC (rev 10)
@@ -0,0 +1,58 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+//
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+//
+[assembly: AssemblyTitle(&quot;&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]		
+
+//
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Revision and Build Numbers 
+// by using the '*' as shown below:
+
+[assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+
+//
+// In order to sign your assembly you must specify a key to use. Refer to the 
+// Microsoft .NET Framework documentation for more information on assembly signing.
+//
+// Use the attributes below to control which key is used for signing. 
+//
+// Notes: 
+//   (*) If no key is specified, the assembly is not signed.
+//   (*) KeyName refers to a key that has been installed in the Crypto Service
+//       Provider (CSP) on your machine. KeyFile refers to a file which contains
+//       a key.
+//   (*) If the KeyFile and the KeyName values are both specified, the 
+//       following processing occurs:
+//       (1) If the KeyName can be found in the CSP, that key is used.
+//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
+//           in the KeyFile is installed into the CSP and used.
+//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
+//       When specifying the KeyFile, the location of the KeyFile should be
+//       relative to the project output directory which is
+//       %Project Directory%\obj\&lt;configuration&gt;. For example, if your KeyFile is
+//       located in the project directory, you would specify the AssemblyKeyFile 
+//       attribute as [assembly: AssemblyKeyFile(&quot;..\\..\\mykey.snk&quot;)]
+//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
+//       documentation for more information on this.
+//
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]
+[assembly: AssemblyKeyName(&quot;&quot;)]

Added: trunk/Frame.cs
===================================================================
--- trunk/Frame.cs	2005-05-25 15:33:39 UTC (rev 9)
+++ trunk/Frame.cs	2005-05-26 11:49:25 UTC (rev 10)
@@ -0,0 +1,492 @@
+//	mp3.NET MPEG Decoder
+//	(c) 2005, mp3.NET Developers
+//
+//	This library is free software; you can redistribute 
+//	it and/or modify it under the terms of the 
+//	GNU Lesser General Public License as published by the 
+//	Free Software Foundation; either version 2.1 of the License, 
+//	or (at your option) any later version.
+//
+//	This library is distributed in the hope that it will be useful, 
+//	but WITHOUT ANY WARRANTY; without even the implied warranty of 
+//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
+//	GNU Lesser General Public License for more details.
+//
+//	You should have received a copy of the GNU Lesser General 
+//	Public License along with this library; if not, write to the 
+//	Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+//	Boston, MA 02111-1307 USA
+
+using System;
+using System.IO;
+
+namespace MP3Net
+{
+	/// &lt;summary&gt;
+	/// Summary description for Class1.
+	/// &lt;/summary&gt;
+	public class Frame
+	{
+
+		public class Granule
+		{
+			public Channel[] channels;
+		}
+
+		public class Channel
+		{
+			public int part_23_length;
+			public int big_value;
+			public int global_gain;
+			public int scalefac_compress;
+			public int window_switching_flag;
+			public int block_type;
+			public int mixed_block_flag;
+			public Region[] regions;
+			public Window[] windows;
+			public int region0_count;
+			public int region1_count;
+			public int preflag;
+			public int scalefac_scale;
+			public int countltable_select;
+
+			public int slen1;
+			public int slen2;
+			public int slen3;
+			public int slen4;
+			public int nrsfb1;
+			public int nrsfb2;
+			public int nrsfb3;
+			public int nrsfb4;
+			public short id;
+		}
+
+		public class Region
+		{
+			public int table_select;
+		}
+
+		public class Window
+		{
+			public int subblock_gain;
+		}
+
+		public Header header;
+		private byte[] sidedata;
+		private Stream maindata;
+		private Stream source;
+		public int main_data_begin;
+		private bool[][] scfsi = new bool[2][];
+		private Granule[] granules;
+		private int[][] part_23_length = new int[2][];
+		private int[][] big_values = new int[2][];
+		private int[][] global_gains = new int[2][];
+		private int[][] sf_compress = new int[2][];
+
+		public Frame(Header frameheader, Stream sourceStream)
+		{
+			scfsi[0] = new bool[4];
+			scfsi[1] = new bool[4];
+			part_23_length[0] = new int[2];
+			part_23_length[1] = new int[2];
+			big_values[0] = new int[2];
+			big_values[1] = new int[2];
+			global_gains[0] = new int[2];
+			global_gains[1] = new int[2];
+			sf_compress[0] = new int[2];
+			sf_compress[1] = new int[2];
+			
+			header = frameheader;
+			source = sourceStream;
+			
+			// let's get our frame's data
+			byte[] data = new byte[header.framelength];
+			long org_pos = source.Position;
+			int headlen = (header.crc) ? 6 : 4;
+			source.Seek(header.position+headlen, SeekOrigin.Begin);
+			source.Read(data, 0, header.framelength-headlen);
+			source.Seek(org_pos, SeekOrigin.Begin);
+
+			// split data
+
+			// select sidedata length
+			int sidedata_len = 0;
+			if(header.mpegversion == Header.MPEG_V1)
+			{
+				if(header.channelmode == Header.MONO)
+				{
+					sidedata_len = 17;
+				} 
+				else 
+				{
+					sidedata_len = 32;
+				}
+			} 
+			else 
+			{
+				if(header.channelmode == Header.MONO)
+				{
+					sidedata_len = 9;
+				} 
+				else 
+				{
+					sidedata_len = 17;
+				}
+			}
+
+			// init buffers
+			sidedata = new byte[sidedata_len];
+			byte[] mdata = new byte[data.Length - sidedata_len];
+
+			// write the data into the buffers
+			MemoryStream audiodata = new MemoryStream(data);
+			audiodata.Read(sidedata, 0, (int)sidedata.Length);
+			audiodata.Read(mdata, 0, (int)mdata.Length);
+
+			// create stream
+			maindata = new MemoryStream(mdata);
+
+			Parse_sidedata();
+		}
+
+		private void Parse_sidedata()
+		{
+			// retrieve main_data_begin
+			BitReader reader = new BitReader(sidedata);
+			if(header.mpegversion == Header.MPEG_V1)
+				main_data_begin = reader.ReadBits(9);
+			else
+				main_data_begin = reader.ReadBits(8);
+
+			// skip private bits
+			if(header.channelmode == Header.MONO)
+				reader.SeekF(6);
+			else
+				reader.SeekF(5);
+
+			// fill scalefactors information array
+			if(header.mpegversion == Header.MPEG_V1)
+			{
+				int i;
+				for(i=0; i&lt;4; i++)
+				{
+					scfsi[0][i] = (reader.ReadBits(1) == 0) ? false : true;
+				}
+				if(header.channelmode != Header.MONO)
+				{
+					for(i=0; i&lt;4; i++)
+					{
+						scfsi[1][i] = (reader.ReadBits(1) == 0) ? false : true;
+					}
+				}
+			}
+
+			granules = (header.mpegversion == Header.MPEG_V1) ? new Granule[2] : new Granule[1];
+			foreach(Granule g in granules)
+			{
+				short chid = 0;
+				g.channels = (header.channelmode == Header.MONO) ? new Channel[1] : new Channel[2];
+				foreach(Channel c in g.channels)
+				{
+					c.id = chid;
+					chid++;
+
+					c.part_23_length = reader.ReadBits(12);
+					c.big_value = reader.ReadBits(9);
+					c.global_gain = reader.ReadBits(8);
+
+					int sfc_len = (header.mpegversion == Header.MPEG_V1) ? 4 : 9;
+					c.scalefac_compress = reader.ReadBits(sfc_len);
+
+					c.window_switching_flag = reader.ReadBits(1);
+					if(c.window_switching_flag == 1)
+					{
+						c.block_type = reader.ReadBits(2);
+						c.mixed_block_flag = reader.ReadBits(1);
+
+						c.regions = new Region[2];
+						foreach(Region r in c.regions)
+						{
+							r.table_select = reader.ReadBits(5);
+						}
+
+						c.windows = new Window[3];
+						foreach(Window w in c.windows)
+						{
+							w.subblock_gain = reader.ReadBits(3);
+						}
+					}  
+					else 
+					{
+						c.regions = new Region[3];
+						foreach(Region r in c.regions)
+						{
+							r.table_select = reader.ReadBits(5);
+						}
+
+						c.region0_count = reader.ReadBits(4);
+						c.region1_count = reader.ReadBits(3);
+					}
+
+					if(header.mpegversion == Header.MPEG_V1)
+						c.preflag = reader.ReadBits(1);
+
+					c.scalefac_scale = reader.ReadBits(1);
+					c.countltable_select = reader.ReadBits(1);
+
+
+					if(header.mpegversion == Header.MPEG_V1)
+					{
+						switch(c.scalefac_compress)
+						{
+							case 0:
+							case 1:
+							case 2:
+							case 3:
+								c.slen1 = 0;
+								break;
+							case 4:
+							case 11:
+							case 12:
+							case 13:
+								c.slen1 = 3;
+								break;
+							case 5:
+							case 6:
+							case 7:
+								c.slen1 = 1;
+								break;
+							case 8:
+							case 9:
+							case 10:
+								c.slen1 = 2;
+								break;
+							case 14:
+							case 15:
+								c.slen1 = 4;
+								break;
+						}
+						switch(c.scalefac_compress)
+						{
+							case 0:
+							case 4:
+								c.slen2 = 0;
+								break;
+							case 1:
+							case 5:
+							case 8:
+							case 11:
+								c.slen2 = 1;
+								break;
+							case 2:
+							case 6:
+							case 9:
+							case 12:
+							case 14:
+								c.slen2 = 1;
+								break;
+							case 3:
+							case 7:
+							case 10:
+							case 13:
+							case 15:
+								c.slen2 = 3;
+								break;
+						}
+
+					}	 
+					else 
+					{	 // MPEG2
+						
+						if(!( (header.modeext == Header.BAND8TO31 | header.modeext == Header.BAND16TO31) &amp;&amp; (c.id == 1) ))
+						{
+							if(c.scalefac_compress &lt; 400)
+							{
+								c.slen1 = (c.scalefac_compress &gt;&gt; 4) / 5;
+								c.slen2 = (c.scalefac_compress &gt;&gt; 4) % 5;
+								c.slen3 = (c.scalefac_compress % 16) &gt;&gt; 2;
+								c.slen4 = (c.scalefac_compress % 4);
+								c.preflag = 0;
+								if(c.block_type != 10)
+								{
+									c.nrsfb1 = 6;
+									c.nrsfb2 = 5;
+									c.nrsfb3 = 5;
+									c.nrsfb4 = 5;
+								} 
+								else 
+								{
+									if(c.mixed_block_flag == 0)
+									{
+										c.nrsfb1 = c.nrsfb2 = c.nrsfb3 = c.nrsfb4 = 9;
+									} 
+									else 
+									{
+										c.nrsfb1 = 6;
+										c.nrsfb2 = c.nrsfb3 = c.nrsfb4 = 9;
+									}
+								}
+							} 
+							else if(c.scalefac_compress &lt; 500) 
+							{
+								c.slen1 = ((c.scalefac_compress-400) &gt;&gt; 2)/5;
+								c.slen2 = ((c.scalefac_compress-400) &gt;&gt; 2)%5;
+								c.slen3 = (c.scalefac_compress-400)%4;
+								c.slen4 = 0;
+								c.preflag = 0;
+								if(c.block_type != 10)
+								{
+									c.nrsfb1 = 6;
+									c.nrsfb2 = 5;
+									c.nrsfb3 = 7;
+									c.nrsfb4 = 3;
+								} 
+								else 
+								{
+									if(c.mixed_block_flag == 0)
+									{
+										c.nrsfb1 = 9;
+										c.nrsfb2 = 9;
+										c.nrsfb3 = 12;
+										c.nrsfb4 = 6;
+									} 
+									else 
+									{
+										c.nrsfb1 = 6;
+										c.nrsfb2 = 9;
+										c.nrsfb3 = 12;
+										c.nrsfb4 = 6;
+									}
+								}
+							} 
+							else if(c.scalefac_compress &lt; 512) 
+							{
+								c.slen1 = (c.scalefac_compress-500)/3;
+								c.slen2 = (c.scalefac_compress-500)%3;
+								c.slen3 = 0;
+								c.slen4 = 0;
+								c.preflag = 1;
+								if(c.block_type != 10)
+								{
+									c.nrsfb1 = 11;
+									c.nrsfb2 = 10;
+									c.nrsfb3 = 0;
+									c.nrsfb4 = 0;
+								} 
+								else 
+								{
+									c.nrsfb2 = 18;
+									c.nrsfb3 = 0;
+									c.nrsfb4 = 0;
+									if(c.mixed_block_flag == 0)
+									{
+										c.nrsfb1 = 18;
+									} 
+									else 
+									{
+										c.nrsfb1 = 15;
+									}
+								}
+							}
+						}  
+						else 
+						{
+
+						}
+					}
+				}
+			}			
+		}
+
+		//TODO: CRC check
+	}
+
+	public class BitReader
+	{
+		private byte[] bytedata;
+		private int pos;
+
+		public BitReader (byte[] data)
+		{
+			this.bytedata = data;
+			pos = 0;
+		}
+
+		public int Position
+		{
+			get
+			{
+				return pos;
+			}
+			set
+			{
+				pos = value;
+			}
+		}
+
+		public void SeekF( int nr )
+		{
+			pos += nr;
+		}
+
+		public void SeekB( int nr )
+		{
+			pos -= nr;
+			if(pos &lt; 0)
+			{
+				pos = 0;
+			}
+		}
+
+		public int ReadBits(int nr)
+		{
+			int bytenr = Convert.ToInt32(Math.Floor(pos / 8));
+			int i;
+			int bytepos = pos - (bytenr * 8);
+			int returnval = 0;
+			for(i = 0; i &lt; nr; i++)
+			{
+				int bitselector = 0;
+				switch(bytepos)
+				{
+					case 0:
+						bitselector = 128;
+						break;
+					case 1:
+						bitselector = 64;
+						break;
+					case 2:
+						bitselector = 32;
+						break;
+					case 3:
+						bitselector = 16;
+						break;
+					case 4:
+						bitselector = 8;
+						break;
+					case 5:
+						bitselector = 4;
+						break;
+					case 6:
+						bitselector = 2;
+						break;
+					case 7:
+						bitselector = 1;
+						break;
+					case 8:
+						bytenr++;
+						bytepos = 0;
+						bitselector = 128;
+						break;
+				}
+				if(bytenr &gt;= bytedata.Length)
+				{
+					break;
+				}
+				returnval += ((bytedata[bytenr] &amp; bitselector) == bitselector) ? Convert.ToInt32(Math.Pow(2, nr - (i+1))) : 0;
+				bytepos++;
+			}
+			return returnval;
+		}
+	}
+}

Added: trunk/Header.cs
===================================================================
--- trunk/Header.cs	2005-05-25 15:33:39 UTC (rev 9)
+++ trunk/Header.cs	2005-05-26 11:49:25 UTC (rev 10)
@@ -0,0 +1,328 @@
+//	mp3.NET MPEG Decoder
+//	(c) 2005, mp3.NET Developers
+//
+//	This library is free software; you can redistribute 
+//	it and/or modify it under the terms of the 
+//	GNU Lesser General Public License as published by the 
+//	Free Software Foundation; either version 2.1 of the License, 
+//	or (at your option) any later version.
+//
+//	This library is distributed in the hope that it will be useful, 
+//	but WITHOUT ANY WARRANTY; without even the implied warranty of 
+//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
+//	GNU Lesser General Public License for more details.
+//
+//	You should have received a copy of the GNU Lesser General 
+//	Public License along with this library; if not, write to the 
+//	Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+//	Boston, MA 02111-1307 USA
+
+using System;
+using System.Collections;
+
+namespace MP3Net
+{
+	/// &lt;summary&gt;
+	/// Summary description for Header.
+	/// &lt;/summary&gt;
+	public class Header
+	{
+		public byte[] head;
+
+		public long position;
+
+		public short mpegversion;
+		public const short MPEG_V25 = 3;
+		public const short MPEG_V2 = 2;
+		public const short MPEG_V1 = 1;
+
+		public short mpeglayer;
+		public const short LAYER3 = 3;
+		public const short LAYER2 = 2;
+		public const short LAYER1 = 1;
+
+		public bool crc;
+		public byte[] crcbytes = new byte[2];
+
+		private int[][][] b_rates;
+		public int bitrate;
+
+		public bool padding;
+
+		public int frequency;
+
+		public short channelmode;
+		public const short MONO = 1;
+		public const short DUAL_CHANNEL = 2;
+		public const short JOINT_STEREO = 3;
+		public const short STEREO = 4;
+
+		public short modeext;
+		public const short BAND4TO31 = 1;
+		public const short BAND8TO31 = 2;
+		public const short BAND12TO31 = 3;
+		public const short BAND16TO31 = 4;
+		public bool stereoInt;
+		public bool stereoMS;
+
+		public int framelength;
+
+		public Header (byte[] head, long position)
+		{
+			b_rates = new int[3][][];
+			b_rates[0] = new int[3][];
+			b_rates[1] = new int[3][];
+			b_rates[0][0] = new int[]{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448};
+			b_rates[0][1] = new int[]{0,32,48,56,64,80,96,112,128,160,192,224,256,320,384};
+			b_rates[0][2] = new int[]{0,32,40,48,56,64,80,96,112,128,160,192,224,256,320};
+			b_rates[1][0] = new int[]{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256};
+			b_rates[1][1] = new int[]{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160};
+			b_rates[1][2] = b_rates[1][1];
+			b_rates[2] = b_rates[1];
+
+			this.head = head;
+			this.position = position;
+		}
+
+		public long NextFrame()
+		{
+			long newpos = position + framelength;
+			return newpos;
+		}
+
+		public override String ToString()
+		{
+			String output = &quot;&quot;;
+			switch(mpegversion)
+			{
+				case MPEG_V1:
+					output += &quot;MPEG 1 &quot;;
+					break;
+				case MPEG_V2:
+					output += &quot;MPEG 2 &quot;;
+					break;
+				case MPEG_V25:
+					output += &quot;MPEG 2.5 &quot;;
+					break;
+			}
+			switch(mpeglayer)
+			{
+				case LAYER1:
+					output += &quot;Layer I &quot;;
+					break;
+				case LAYER2:
+					output += &quot;Layer II &quot;;
+					break;
+				case LAYER3:
+					output += &quot;Layer III &quot;;
+					break;
+			}
+			if(crc)
+				output += &quot;CRC protected &quot;;
+			if(bitrate &gt; 0)
+				output += bitrate.ToString() + &quot;kbps &quot;;
+			if(frequency &gt; 0)
+				output += frequency.ToString() + &quot;Hz &quot;;
+			switch(channelmode)
+			{
+				case MONO:
+					output += &quot;Mono &quot;;
+					break;
+				case DUAL_CHANNEL:
+					output += &quot;Dual Channel &quot;;
+					break;
+				case JOINT_STEREO:
+					output += &quot;Joint Stereo &quot;;
+					break;
+				case STEREO:
+					output += &quot;Stereo &quot;;
+					break;
+			}
+			if(padding)
+				output += &quot;Padded &quot;;
+
+			return output;
+		}
+		
+		public bool Init()
+		{
+			// extract version
+			switch(head[1] &amp; 24)
+			{
+				case 0:
+					mpegversion = MPEG_V25;
+					break;
+				case 16:
+					mpegversion = MPEG_V2;
+					break;
+				case 24:
+					mpegversion = MPEG_V1;
+					break;
+				default:
+					return false;
+			}
+
+			// extract layer
+			switch(head[1] &amp; 6)
+			{
+				case 2:
+					mpeglayer = LAYER3;
+					break;
+				case 4:
+					mpeglayer = LAYER2;
+					break;
+				case 6:
+					mpeglayer = LAYER1;
+					break;
+				default:
+					return false;
+			}
+
+			// crc protection?
+			switch(head[1] &amp; 1)
+			{
+				case 1:
+					crc = false;
+					break;
+				case 0:
+					crc = true;
+					break;
+				default:
+					return false;
+			}
+
+			// extract bitrate
+			int bitrate_index = (head[2] &gt;&gt; 4) &amp; 15;
+			bitrate = b_rates[(mpegversion-1)][(mpeglayer-1)][bitrate_index];
+			if(bitrate &lt;= 0)
+				return false;
+
+			// extract sampling frequency
+			switch(head[2] &amp; 12)
+			{
+				case 0:
+					if(mpegversion == MPEG_V1)
+					{
+						frequency = 44100;
+					} 
+					else if (mpegversion == MPEG_V2) 
+					{
+						frequency = 22050;
+					} 
+					else if (mpegversion == MPEG_V25)
+					{
+						frequency = 11025;
+					}
+					break;
+				case 4:
+					if(mpegversion == MPEG_V1)
+					{
+						frequency = 48000;
+					} 
+					else if (mpegversion == MPEG_V2) 
+					{
+						frequency = 24000;
+					} 
+					else if (mpegversion == MPEG_V25)
+					{
+						frequency = 12000;
+					}
+					break;
+				case 8:
+					if(mpegversion == MPEG_V1)
+					{
+						frequency = 32000;
+					} 
+					else if (mpegversion == MPEG_V2) 
+					{
+						frequency = 16000;
+					} 
+					else if (mpegversion == MPEG_V25)
+					{
+						frequency = 8000;
+					}
+					break;
+				default:
+					return false;
+			}
+
+			// padded frame or not?
+			switch(head[2] &amp; 2)
+			{
+				case 2:
+					padding = true;
+					break;
+				case 0:
+					padding = false;
+					break;
+				default:
+					return false;
+			}
+
+			// extract channel mode
+			switch(head[3] &amp; 192)
+			{
+				case 0:				  
+					channelmode = STEREO;
+					break;
+				case 64:
+					channelmode = JOINT_STEREO;
+					break;
+				case 128:
+					channelmode = DUAL_CHANNEL;
+					break;
+				case 192:
+					channelmode = MONO;
+					break;
+				default:
+					return false;
+			}
+
+			// mode extension for joint stereo
+			if( channelmode == JOINT_STEREO )
+			{
+				switch(head[3] &amp; 48)
+				{
+					case 0:
+						modeext = BAND4TO31;
+						stereoInt = false;
+						stereoMS = false;
+						break;
+					case 16:
+						modeext = BAND8TO31;
+						stereoInt = true;
+						stereoMS = false;
+						break;
+					case 32:
+						modeext = BAND12TO31;
+						stereoInt = false;
+						stereoMS = true;
+						break;
+					case 48:
+						modeext = BAND16TO31;
+						stereoInt = true;
+						stereoMS = true;
+						break;
+					default:
+						return false;
+				}
+			}
+
+			// calc framelength
+			int padding_int = (padding) ? 1 : 0;
+			if(mpegversion == MPEG_V1)
+			{
+				
+				framelength = ((1152*bitrate*1000)/frequency)/8 + padding_int;
+			} 
+			else 
+			{
+				framelength = ((576*bitrate*1000)/frequency)/8 + padding_int;
+			}
+
+			//throw new Exception();
+
+			return true;
+		}
+	}
+}
\ No newline at end of file

Added: trunk/MP3Stream.cs
===================================================================
--- trunk/MP3Stream.cs	2005-05-25 15:33:39 UTC (rev 9)
+++ trunk/MP3Stream.cs	2005-05-26 11:49:25 UTC (rev 10)
@@ -0,0 +1,186 @@
+//	mp3.NET MPEG Decoder
+//	(c) 2005, mp3.NET Developers
+//
+//	This library is free software; you can redistribute 
+//	it and/or modify it under the terms of the 
+//	GNU Lesser General Public License as published by the 
+//	Free Software Foundation; either version 2.1 of the License, 
+//	or (at your option) any later version.
+//
+//	This library is distributed in the hope that it will be useful, 
+//	but WITHOUT ANY WARRANTY; without even the implied warranty of 
+//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
+//	GNU Lesser General Public License for more details.
+//
+//	You should have received a copy of the GNU Lesser General 
+//	Public License along with this library; if not, write to the 
+//	Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+//	Boston, MA 02111-1307 USA
+
+using System;
+using System.IO;
+using System.Collections;
+
+namespace MP3Net
+{
+	/// &lt;summary&gt;
+	/// Summary description for Class1.
+	/// &lt;/summary&gt;
+	class MP3Stream
+	{
+		/// &lt;summary&gt;
+		/// The main entry point for the application.
+		/// &lt;/summary&gt;
+		[STAThread]
+		static void Main(string[] args)
+		{
+			//HACK: test file
+			MP3Stream mp3 = new MP3Stream(new FileStream(&quot;growl.mp3&quot;, FileMode.Open));
+		}
+
+		private Stream source;
+		ArrayList headerstream = new ArrayList();
+		byte[] comparebuffer = new byte[4];
+		int currentframe = 0;
+
+		public MP3Stream (Stream source)
+		{
+			source.Seek(0, SeekOrigin.Begin);
+			this.source = source;
+			SeekHeader();
+			Frame firstframe = new Frame((Header)headerstream[0], source);
+			Console.WriteLine(&quot;MDB &quot; + firstframe.main_data_begin);
+			firstframe = new Frame((Header)headerstream[1], source);
+			Console.WriteLine(&quot;MDB &quot; + firstframe.main_data_begin);
+			firstframe = new Frame((Header)headerstream[2], source);
+			Console.WriteLine(&quot;MDB &quot; + firstframe.main_data_begin);
+			firstframe = new Frame((Header)headerstream[3], source);
+			Console.WriteLine(&quot;MDB &quot; + firstframe.main_data_begin);
+			firstframe = new Frame((Header)headerstream[4], source);
+			Console.WriteLine(&quot;MDB &quot; + firstframe.main_data_begin);
+		}
+
+		public int Frequency
+		{
+			get
+			{
+				return ((Header)headerstream[0]).frequency;
+			}
+		}
+
+		public short Channels
+		{
+			get
+			{
+				return (((Header)headerstream[0]).channelmode == Header.MONO) ? (short)1 : (short)2;
+			}
+		}
+
+		public int ReadFrame(byte[] buffer)
+		{
+			buffer = new byte[((Header)headerstream[currentframe]).framelength];
+			Frame thisframe = new Frame((Header)headerstream[currentframe], source);
+			//int read = thisframe.Decode(buffer);
+			currentframe++;
+			return 0;
+		}
+
+		private void SeekHeader()
+		{
+			byte[] buffer = new byte[4];
+			do
+			{
+				// read 4 bytes (possible header)
+				int read = source.Read(buffer, 0, 4);
+
+				// less than 4 bytes read -&gt; EOF
+				if(read &lt; 4)
+				{
+					break;
+				}
+
+				// check for typical header strucure
+				if(SyncCheck(buffer))
+				{
+					// load the header bytes into the header class
+					Header head = new Header(buffer, (source.Position-4));
+
+					// extract header information and do another check for invalid values
+					if(head.Init())
+					{
+						// if frame contains CRC bytes, copy them to the header
+						if(head.crc)
+						{
+							source.Read(head.crcbytes, 0, 2);
+							source.Seek(-2, SeekOrigin.Current);
+						}
+
+						// check if the frame length matches the header data
+						byte[] syncbytes = new byte[4];
+						long currentpos = source.Position;
+						source.Seek(head.NextFrame(), SeekOrigin.Begin);
+						source.Read(syncbytes, 0, 4);
+						source.Seek(-1, SeekOrigin.Current);
+						// do we have another header?
+						if(SyncCheck(syncbytes))
+						{
+							// first header?
+							if(headerstream.Count &lt;= 0)
+							{
+								if(SyncCompare(buffer, syncbytes)) // check if MPEG Version / Layer matches those of the next header (to reduce chance to catch noise)
+								{
+									comparebuffer = (byte[])buffer.Clone();
+
+									// we have found a frame!
+									headerstream.Add(head);
+									Console.WriteLine(head.ToString());
+									//break;
+								}  
+								else 
+								{
+									// resume search where we left
+									source.Seek(currentpos, SeekOrigin.Begin);
+								}
+							
+							}   
+							else  // not the first header, so we don't do more checks to save some time 
+							{
+								// we have found a frame!
+								headerstream.Add(head);
+								//Console.WriteLine(head.ToString());
+							}  
+						}
+
+					}
+				}  
+
+				// move 1 byte per cycle (instead of 4)
+				source.Seek(-3, SeekOrigin.Current);
+
+			} while (true);
+			
+			Console.WriteLine(&quot;Frames: &quot; + headerstream.Count.ToString());
+
+			if(headerstream.Count &lt;= 0)
+			{
+				throw new Exception(&quot;Could not find MPEG headers&quot;);
+			}
+		}
+
+		private bool SyncCheck(byte[] buffer)
+		{
+			//      byte0 = 11111111      byte1 = 111xxxxx			    byte2 != 111111xx			  byte2 != 0000xxxx	  AND NOT	byte1 = xxx01xxx		   byte1 = xxxxx00x			 byte2 = xxxx11xx			 byte3 = xxxxxx10
+			return (buffer[0] == 255 &amp;&amp; ((buffer[1] &amp; 224) == 224) &amp;&amp; ((buffer[2] &amp; 252) != 252) &amp;&amp; ((buffer[2] &amp; 240) != 0) &amp;&amp; !(((buffer[1] &amp; 24) == 8) || ((buffer[1] &amp; 6) == 0) || ((buffer[2] &amp; 12) == 12) || ((buffer[3] &amp; 3) == 2)));
+		}
+
+		private bool SyncCompare(byte[] buffera, byte[] bufferb)
+		{
+			//  equal mpeg version / layer   equal mode, copyright etc.					equal frequency
+			if( buffera[1] == bufferb[1] &amp;&amp; (buffera[3] &amp; 207) == (bufferb[3] &amp; 207) &amp;&amp; (buffera[2] &amp; 12) == (bufferb[2] &amp; 12) )
+			{
+				return true;
+			}
+			return false;
+		}
+	}
+}

Added: trunk/dnpb.exe
===================================================================
(Binary files differ)


Property changes on: trunk/dnpb.exe
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/prebuild.xml
===================================================================
--- trunk/prebuild.xml	2005-05-25 15:33:39 UTC (rev 9)
+++ trunk/prebuild.xml	2005-05-26 11:49:25 UTC (rev 10)
@@ -0,0 +1,46 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; 
+&lt;DNPreBuild xmlns=&quot;<A HREF="http://dnpb.sourceforge.net/schemas/dnpb-1.4.xsd">http://dnpb.sourceforge.net/schemas/dnpb-1.4.xsd</A>&quot;&gt;
+	&lt;Solution name=&quot;mp3.NET&quot;&gt;
+		&lt;Configuration name=&quot;Debug&quot;&gt;
+			&lt;Options&gt;
+			    &lt;?if OS = &quot;Win32&quot; ?&gt;
+				&lt;CompilerDefines&gt;DEBUG;TRACE;WIN32&lt;/CompilerDefines&gt;
+				&lt;?else ?&gt;
+				&lt;CompilerDefines&gt;DEBUG;TRACE;POSIX&lt;/CompilerDefines&gt;
+				&lt;?endif ?&gt;
+				&lt;OptimizeCode&gt;false&lt;/OptimizeCode&gt;
+				&lt;OutputPath&gt;./bin/Debug&lt;/OutputPath&gt;
+				&lt;DebugInformation&gt;true&lt;/DebugInformation&gt;
+			&lt;/Options&gt;
+		&lt;/Configuration&gt;
+		
+		&lt;Configuration name=&quot;Release&quot;&gt;
+			&lt;Options&gt;
+			    &lt;?if OS = &quot;Win32&quot; ?&gt;
+				&lt;CompilerDefines&gt;TRACE;WIN32&lt;/CompilerDefines&gt;
+				&lt;?else ?&gt;
+				&lt;CompilerDefines&gt;TRACE;POSIX&lt;/CompilerDefines&gt;
+				&lt;?endif ?&gt;
+				&lt;OutputPath&gt;./bin/Release&lt;/OutputPath&gt;
+				&lt;OptimizeCode&gt;true&lt;/OptimizeCode&gt;
+				&lt;DebugInformation&gt;false&lt;/DebugInformation&gt;
+			&lt;/Options&gt;
+		&lt;/Configuration&gt;
+		
+		&lt;Project 
+			name=&quot;mp3.NET&quot; 
+			type=&quot;Exe&quot; 
+			path=&quot;./&quot;
+			language=&quot;C#&quot; 
+			runtime=&quot;Microsoft&quot; 
+			icon=&quot;App.ico&quot;&gt;
+
+			&lt;Reference name=&quot;System&quot; /&gt;
+			&lt;Reference name=&quot;System.Data&quot; /&gt;
+			
+			&lt;Files&gt;
+				&lt;Match pattern=&quot;*.cs&quot; path=&quot;./&quot; recurse=&quot;false&quot;/&gt;
+			&lt;/Files&gt;
+		&lt;/Project&gt;
+	&lt;/Solution&gt;
+&lt;/DNPreBuild&gt;
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000004.html">[Agex-svn] r9 - in trunk/AGES: . AGESDemo DirectSound OpenAL
</A></li>
	<LI>Next message: <A HREF="000006.html">[Agex-svn] r11 - in trunk: . mp3.NET
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5">[ date ]</a>
              <a href="thread.html#5">[ thread ]</a>
              <a href="subject.html#5">[ subject ]</a>
              <a href="author.html#5">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/agex-svn">More information about the Agex-svn
mailing list</a><br>
</body></html>
